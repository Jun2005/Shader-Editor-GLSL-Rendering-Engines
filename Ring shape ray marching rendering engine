#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

uniform vec2 resolution;
uniform vec2 touch;
uniform vec2 touchStart;
uniform int pointerCount;
uniform sampler2D backbuffer;
uniform int frame;

//param
vec3 bgColor = vec3(0.08,0.05,0.08);
vec3 cameraPos = vec3(0.0,0.0,-7.5);
float fov = 40.0;
int iterations = 30;
int iterations2 = 12;
float epsilon = 0.01;
float maxDist = 50.0;
vec3 sunPos = vec3(1.0,1.0,-2.0);
vec3 sunColor = vec3(0.2,0.15,0.1);
float specularPower = 25.0;
float rotSense = 0.005;
vec2 rotation = vec2(0.0,0.0);
float nScale = 1.0;
float artifact = 1.0;
vec3 color1 = vec3(0.12,0.03,0.13);
vec3 color2 = vec3(0.85,0.3,0.83);

vec3 rotX(vec3 pos, float rad){
  return vec3(pos.x,pos.y*cos(rad)-pos.z*sin(rad),pos.y*sin(rad)+pos.z*cos(rad));
}
vec3 rotY(vec3 pos, float rad){
  return vec3(pos.x*cos(rad)+pos.z*sin(rad),pos.y,-pos.x*sin(rad)+pos.z*cos(rad));
}

float torusSDF(vec3 pos,vec3 origin){
  return length(vec2(length(pos.xz)-1.5,pos.y))-0.8;
}

float torusSDF2(vec3 pos,vec3 origin){
  return length(vec2(length(pos.xz)-1.5,pos.y))-0.7;
}

float SDF(vec3 pos,vec2 rot){
  pos = rotX(pos, rot.x);
  pos = rotY(pos, rot.y);
  return torusSDF(pos, vec3(0.0,0.0,0.0));
}

float SDF3(vec3 pos,vec2 rot){
  pos = rotX(pos, rot.x);
  pos = rotY(pos, rot.y);
  return torusSDF2(pos, vec3(0.0,0.0,0.0));
}

vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}

float cnoise(vec3 P){
  vec3 Pi0 = floor(P); // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod(Pi0, 289.0);
  Pi1 = mod(Pi1, 289.0);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 / 7.0;
  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 / 7.0;
  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return 2.2 * n_xyz;
}

float noise(vec3 a){
  // Properties
  int octaves = 10;
  float lacunarity = 1.8;
  float gain = 0.6;

  float amplitude = 0.5;
  float frequency = 1.0;

  float b = 0.0;
  for (int i = 0; i < octaves; i++) {
    b += amplitude * cnoise(frequency*a);
    frequency *= lacunarity;
    amplitude *= gain;
  }
  return b;
}

float noiseSDF(vec3 pos){
  return max(0.0,((noise(pos*nScale)+1.0)/2.0-0.4)*artifact);
}

float SDF2(vec3 pos,vec2 rot){
  pos = rotX(pos, rot.x);
  pos = rotY(pos, rot.y);
  return noiseSDF(pos);
}

vec3 rayDir(){
  vec2 centeredCoord = gl_FragCoord.xy-resolution/2.0;
  float hFov = fov/2.0;
  float nearPlane = (resolution.x/2.0)/tan(radians(hFov));
  vec3 dir = normalize(vec3(centeredCoord, nearPlane));
  return dir;
}

float findDepth(vec2 rot){
  float dist=0.0;
  float change=0.0;
  for (int i=0;i<iterations;i++){
    change = SDF(cameraPos+rayDir()*dist,rot);
    if(change<=epsilon){
      dist+=change;
      break;
    }
    dist+=change;
    if(dist>maxDist){
      dist=maxDist;
      break;
    }
  }
  return dist;
}

float findDepth3(vec2 rot){
  float dist=0.0;
  float change=0.0;
  for (int i=0;i<iterations;i++){
    change = SDF3(cameraPos+rayDir()*dist,rot);
    if(change<=epsilon){
      dist+=change;
      break;
    }
    dist+=change;
    if(dist>maxDist){
      dist=maxDist;
      break;
    }
  }
  return dist;
}

float findDepth2(vec2 rot,vec3 surfacePos){
  float dist=0.0;
  float change=0.0;
  for (int i=0;i<iterations2;i++){
    change = SDF2(surfacePos+rayDir()*dist,rot);
    if(change<=epsilon){
      dist+=change;
      break;
    }
    dist+=change;
    if(dist>maxDist){
      dist=maxDist;
      break;
    }
  }
  return dist;
}

vec3 findNormal(vec3 surfacePos,vec2 rot){
  vec3 normal = vec3(0.0,0.0,0.0);
  normal.x = SDF(vec3(epsilon,0.0,0.0)+surfacePos,rot)-SDF(vec3(-epsilon,0.0,0.0)+surfacePos,rot);
  normal.y = SDF(vec3(0.0,epsilon,0.0)+surfacePos,rot)-SDF(vec3(0.0,-epsilon,0.0)+surfacePos,rot);
  normal.z = SDF(vec3(0.0,0.0,epsilon)+surfacePos,rot)-SDF(vec3(0.0,0.0,-epsilon)+surfacePos,rot);
  return normalize(normal);
}

float diffuse(vec3 normal, vec3 surfacePos){
  return clamp(dot(normal, normalize(sunPos-surfacePos)),0.0,1.0);
}

float specular(vec3 normal, vec3 surfacePos){
  vec3 midDir = normalize((-rayDir()+normalize(sunPos-surfacePos))/2.0);
  return pow(clamp(dot(normal, midDir),0.0,1.0),specularPower);
}

float remap(float x,float iMin, float iMax, float oMin, float oMax){
  float ans = min(max(iMin, x),iMax);
  return (ans-iMin)/(iMax-iMin)*(oMax-oMin)+oMin;
}

vec3 colorLerp(float x, vec3 a, vec3 b){
  vec3 c = b-a;
  return a+x*c;
}

float fresnel(vec3 normal){
  return pow(1.0-dot(normal,-rayDir()),2.0);
}

float hash(float x) { return fract(x + 1.3215 * 1.8152); }

float hash3(vec3 a) { return fract((hash(a.z * 42.8883) + hash(a.y * 36.9125) + hash(a.x * 65.4321)) * 291.1257); }

vec3 rehash3(float x) { return vec3(hash(((x + 0.5283) * 59.3829) * 274.3487), hash(((x + 0.8192) * 83.6621) * 345.3871), hash(((x + 0.2157f) * 36.6521f) * 458.3971f)); }

float sqr(float x) {return x*x;}
float fastdist(vec3 a, vec3 b) { return sqr(b.x - a.x) + sqr(b.y - a.y) + sqr(b.z - a.z); }

vec2 eval(float x, float y, float z,vec2 rot) {
    vec3 pos = vec3(x,y,z);
    pos = rotX(pos, rot.x);
    pos = rotY(pos, rot.y);
    x = pos.x;
    y = pos.y;
    z = pos.z;
    vec4 p[27];
    for (int _x = -1; _x < 2; _x++) for (int _y = -1; _y < 2; _y++) for(int _z = -1; _z < 2; _z++) {
        vec3 _p = vec3(floor(x), floor(y), floor(z)) + vec3(_x, _y, _z);
        float h = hash3(_p);
        p[(_x + 1) + ((_y + 1) * 3) + ((_z + 1) * 3 * 3)] = vec4((rehash3(h) + _p).xyz, h);
    }
    float m = 9999.9999, w = 0.0;
    for (int i = 0; i < 27; i++) {
        float d = fastdist(vec3(x, y, z), p[i].xyz);
        if(d < m) { m = d; w = p[i].w; }
    }
    return vec2(m, w);
}

void main(void) {
  vec3 color = bgColor;
  float depth = 0.0;
  vec3 normal = vec3(0.0,0.0,0.0);
  float brightness = 0.0;
  vec3 surfacePos = vec3(0.0,0.0,0.0);
  float attenuation = 0.0;
  vec2 prevRot = vec2(0.0,0.0);
  float check = 0.0;
  float tau = radians(180.0)*2.0;

  //get rotation input
  //rotation = vec3(rotSense,rotSense,0.0)*float(frame);
  vec2 diff = (touchStart-touch)*rotSense;
  prevRot = texture2D(backbuffer,vec2(0.0,0.0)).xy*tau;
  check = texture2D(backbuffer,vec2(0.0,0.0)).z;
  if(pointerCount > 0){
    check=1.0;
    rotation = mod(prevRot+vec2(diff.y,-diff.x),tau);
  }
  else{
    if(check==1.0){
      prevRot = mod(prevRot+vec2(diff.y,-diff.x),tau);
      check=0.0;
    }
    rotation = prevRot;
  }

  depth = findDepth(rotation);

  if (depth!=maxDist){
    surfacePos = cameraPos+rayDir()*depth;
    attenuation = remap(distance(surfacePos,sunPos),0.0,maxDist,1.0,0.0);
    normal = findNormal(surfacePos,rotation);
    vec2 n = eval(surfacePos.x, surfacePos.y, surfacePos.z, rotation);
    vec3 col = normalize((1.0 - sqrt(n.x)) * rehash3(n.y));
    normal = normalize(normal+col*0.7);
    brightness = max(diffuse(normal,surfacePos),specular(normal,surfacePos));
    brightness = max(brightness, fresnel(normal));
    brightness *= attenuation;
    float depth3 = findDepth3(rotation);
    vec3 inner = bgColor;
    if (depth3 != maxDist){
      float depth2 = findDepth2(rotation,surfacePos);
      depth2 = remap(depth2,0.0,5.0,0.0,1.0);
      inner = colorLerp(depth2,color1,color2);
    }

    color = inner+sunColor*brightness;
  }

  if(length(gl_FragCoord.xy/resolution)<0.001){
    gl_FragColor = vec4(prevRot/tau,check, 1.0);
  }
  else{
    gl_FragColor = vec4(color,1.0);
  }
} 
